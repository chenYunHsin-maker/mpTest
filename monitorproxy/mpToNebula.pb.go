// Code generated by protoc-gen-go. DO NOT EDIT.
// source: mpToNebula.proto

package monitorproxy

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

//定義了 Echo Server EchoRequest
type EchoRequest struct {
	Message              string   `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EchoRequest) Reset()         { *m = EchoRequest{} }
func (m *EchoRequest) String() string { return proto.CompactTextString(m) }
func (*EchoRequest) ProtoMessage()    {}
func (*EchoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_23da1a2e7ed79914, []int{0}
}

func (m *EchoRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EchoRequest.Unmarshal(m, b)
}
func (m *EchoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EchoRequest.Marshal(b, m, deterministic)
}
func (m *EchoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EchoRequest.Merge(m, src)
}
func (m *EchoRequest) XXX_Size() int {
	return xxx_messageInfo_EchoRequest.Size(m)
}
func (m *EchoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_EchoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_EchoRequest proto.InternalMessageInfo

func (m *EchoRequest) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

//定義了 Echo Response
//這裡多回傳了一個 叫做 unixtime
type EchoReply struct {
	Message              string   `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
	Unixtime             int64    `protobuf:"varint,2,opt,name=unixtime,proto3" json:"unixtime,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EchoReply) Reset()         { *m = EchoReply{} }
func (m *EchoReply) String() string { return proto.CompactTextString(m) }
func (*EchoReply) ProtoMessage()    {}
func (*EchoReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_23da1a2e7ed79914, []int{1}
}

func (m *EchoReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EchoReply.Unmarshal(m, b)
}
func (m *EchoReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EchoReply.Marshal(b, m, deterministic)
}
func (m *EchoReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EchoReply.Merge(m, src)
}
func (m *EchoReply) XXX_Size() int {
	return xxx_messageInfo_EchoReply.Size(m)
}
func (m *EchoReply) XXX_DiscardUnknown() {
	xxx_messageInfo_EchoReply.DiscardUnknown(m)
}

var xxx_messageInfo_EchoReply proto.InternalMessageInfo

func (m *EchoReply) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *EchoReply) GetUnixtime() int64 {
	if m != nil {
		return m.Unixtime
	}
	return 0
}

type TrafficLog struct {
	Duration             uint32   `protobuf:"varint,1,opt,name=duration,proto3" json:"duration,omitempty"`
	Sent                 uint64   `protobuf:"varint,2,opt,name=sent,proto3" json:"sent,omitempty"`
	Received             uint64   `protobuf:"varint,3,opt,name=received,proto3" json:"received,omitempty"`
	Dir                  string   `protobuf:"bytes,4,opt,name=dir,proto3" json:"dir,omitempty"`
	Proto                uint32   `protobuf:"varint,5,opt,name=proto,proto3" json:"proto,omitempty"`
	ProtoName            string   `protobuf:"bytes,6,opt,name=proto_name,json=protoName,proto3" json:"proto_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TrafficLog) Reset()         { *m = TrafficLog{} }
func (m *TrafficLog) String() string { return proto.CompactTextString(m) }
func (*TrafficLog) ProtoMessage()    {}
func (*TrafficLog) Descriptor() ([]byte, []int) {
	return fileDescriptor_23da1a2e7ed79914, []int{2}
}

func (m *TrafficLog) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TrafficLog.Unmarshal(m, b)
}
func (m *TrafficLog) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TrafficLog.Marshal(b, m, deterministic)
}
func (m *TrafficLog) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TrafficLog.Merge(m, src)
}
func (m *TrafficLog) XXX_Size() int {
	return xxx_messageInfo_TrafficLog.Size(m)
}
func (m *TrafficLog) XXX_DiscardUnknown() {
	xxx_messageInfo_TrafficLog.DiscardUnknown(m)
}

var xxx_messageInfo_TrafficLog proto.InternalMessageInfo

func (m *TrafficLog) GetDuration() uint32 {
	if m != nil {
		return m.Duration
	}
	return 0
}

func (m *TrafficLog) GetSent() uint64 {
	if m != nil {
		return m.Sent
	}
	return 0
}

func (m *TrafficLog) GetReceived() uint64 {
	if m != nil {
		return m.Received
	}
	return 0
}

func (m *TrafficLog) GetDir() string {
	if m != nil {
		return m.Dir
	}
	return ""
}

func (m *TrafficLog) GetProto() uint32 {
	if m != nil {
		return m.Proto
	}
	return 0
}

func (m *TrafficLog) GetProtoName() string {
	if m != nil {
		return m.ProtoName
	}
	return ""
}

type IDPLog struct {
	Cls                  string   `protobuf:"bytes,1,opt,name=cls,proto3" json:"cls,omitempty"`
	Act                  string   `protobuf:"bytes,2,opt,name=act,proto3" json:"act,omitempty"`
	Sid                  uint32   `protobuf:"varint,3,opt,name=sid,proto3" json:"sid,omitempty"`
	Ob                   string   `protobuf:"bytes,4,opt,name=ob,proto3" json:"ob,omitempty"`
	ObMac                []byte   `protobuf:"bytes,5,opt,name=ob_mac,json=obMac,proto3" json:"ob_mac,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IDPLog) Reset()         { *m = IDPLog{} }
func (m *IDPLog) String() string { return proto.CompactTextString(m) }
func (*IDPLog) ProtoMessage()    {}
func (*IDPLog) Descriptor() ([]byte, []int) {
	return fileDescriptor_23da1a2e7ed79914, []int{3}
}

func (m *IDPLog) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_IDPLog.Unmarshal(m, b)
}
func (m *IDPLog) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_IDPLog.Marshal(b, m, deterministic)
}
func (m *IDPLog) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IDPLog.Merge(m, src)
}
func (m *IDPLog) XXX_Size() int {
	return xxx_messageInfo_IDPLog.Size(m)
}
func (m *IDPLog) XXX_DiscardUnknown() {
	xxx_messageInfo_IDPLog.DiscardUnknown(m)
}

var xxx_messageInfo_IDPLog proto.InternalMessageInfo

func (m *IDPLog) GetCls() string {
	if m != nil {
		return m.Cls
	}
	return ""
}

func (m *IDPLog) GetAct() string {
	if m != nil {
		return m.Act
	}
	return ""
}

func (m *IDPLog) GetSid() uint32 {
	if m != nil {
		return m.Sid
	}
	return 0
}

func (m *IDPLog) GetOb() string {
	if m != nil {
		return m.Ob
	}
	return ""
}

func (m *IDPLog) GetObMac() []byte {
	if m != nil {
		return m.ObMac
	}
	return nil
}

type FirewallLog struct {
	Cls                  string   `protobuf:"bytes,1,opt,name=cls,proto3" json:"cls,omitempty"`
	Ob                   string   `protobuf:"bytes,2,opt,name=ob,proto3" json:"ob,omitempty"`
	ObMac                []byte   `protobuf:"bytes,3,opt,name=ob_mac,json=obMac,proto3" json:"ob_mac,omitempty"`
	Dir                  string   `protobuf:"bytes,4,opt,name=dir,proto3" json:"dir,omitempty"`
	Proto                uint32   `protobuf:"varint,5,opt,name=proto,proto3" json:"proto,omitempty"`
	ProtoName            string   `protobuf:"bytes,6,opt,name=proto_name,json=protoName,proto3" json:"proto_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FirewallLog) Reset()         { *m = FirewallLog{} }
func (m *FirewallLog) String() string { return proto.CompactTextString(m) }
func (*FirewallLog) ProtoMessage()    {}
func (*FirewallLog) Descriptor() ([]byte, []int) {
	return fileDescriptor_23da1a2e7ed79914, []int{4}
}

func (m *FirewallLog) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FirewallLog.Unmarshal(m, b)
}
func (m *FirewallLog) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FirewallLog.Marshal(b, m, deterministic)
}
func (m *FirewallLog) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FirewallLog.Merge(m, src)
}
func (m *FirewallLog) XXX_Size() int {
	return xxx_messageInfo_FirewallLog.Size(m)
}
func (m *FirewallLog) XXX_DiscardUnknown() {
	xxx_messageInfo_FirewallLog.DiscardUnknown(m)
}

var xxx_messageInfo_FirewallLog proto.InternalMessageInfo

func (m *FirewallLog) GetCls() string {
	if m != nil {
		return m.Cls
	}
	return ""
}

func (m *FirewallLog) GetOb() string {
	if m != nil {
		return m.Ob
	}
	return ""
}

func (m *FirewallLog) GetObMac() []byte {
	if m != nil {
		return m.ObMac
	}
	return nil
}

func (m *FirewallLog) GetDir() string {
	if m != nil {
		return m.Dir
	}
	return ""
}

func (m *FirewallLog) GetProto() uint32 {
	if m != nil {
		return m.Proto
	}
	return 0
}

func (m *FirewallLog) GetProtoName() string {
	if m != nil {
		return m.ProtoName
	}
	return ""
}

type GEOIPLog struct {
	CountryCode          string   `protobuf:"bytes,1,opt,name=country_code,json=countryCode,proto3" json:"country_code,omitempty"`
	CityCode             string   `protobuf:"bytes,2,opt,name=city_code,json=cityCode,proto3" json:"city_code,omitempty"`
	CountryName          string   `protobuf:"bytes,3,opt,name=country_name,json=countryName,proto3" json:"country_name,omitempty"`
	CityName             string   `protobuf:"bytes,4,opt,name=city_name,json=cityName,proto3" json:"city_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GEOIPLog) Reset()         { *m = GEOIPLog{} }
func (m *GEOIPLog) String() string { return proto.CompactTextString(m) }
func (*GEOIPLog) ProtoMessage()    {}
func (*GEOIPLog) Descriptor() ([]byte, []int) {
	return fileDescriptor_23da1a2e7ed79914, []int{5}
}

func (m *GEOIPLog) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GEOIPLog.Unmarshal(m, b)
}
func (m *GEOIPLog) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GEOIPLog.Marshal(b, m, deterministic)
}
func (m *GEOIPLog) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GEOIPLog.Merge(m, src)
}
func (m *GEOIPLog) XXX_Size() int {
	return xxx_messageInfo_GEOIPLog.Size(m)
}
func (m *GEOIPLog) XXX_DiscardUnknown() {
	xxx_messageInfo_GEOIPLog.DiscardUnknown(m)
}

var xxx_messageInfo_GEOIPLog proto.InternalMessageInfo

func (m *GEOIPLog) GetCountryCode() string {
	if m != nil {
		return m.CountryCode
	}
	return ""
}

func (m *GEOIPLog) GetCityCode() string {
	if m != nil {
		return m.CityCode
	}
	return ""
}

func (m *GEOIPLog) GetCountryName() string {
	if m != nil {
		return m.CountryName
	}
	return ""
}

func (m *GEOIPLog) GetCityName() string {
	if m != nil {
		return m.CityName
	}
	return ""
}

type Devicelog struct {
	// Represents seconds of UTC time since Unix epoch
	// 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
	// 9999-12-31T23:59:59Z inclusive.
	Timestamp int64  `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	Severity  int32  `protobuf:"varint,2,opt,name=severity,proto3" json:"severity,omitempty"`
	Facility  int32  `protobuf:"varint,3,opt,name=facility,proto3" json:"facility,omitempty"`
	Category  string `protobuf:"bytes,4,opt,name=category,proto3" json:"category,omitempty"`
	// IP address is serialized in network-byte-order. It may
	// either be an IPv4 or IPv6 address.
	// Reference https://github.com/grpc/grpc/blob/master/src/proto/grpc/lb/v1/load_balancer.proto
	Srcip []byte `protobuf:"bytes,5,opt,name=srcip,proto3" json:"srcip,omitempty"`
	Dstip []byte `protobuf:"bytes,6,opt,name=dstip,proto3" json:"dstip,omitempty"`
	// IP protocol
	Ipproto int32 `protobuf:"varint,7,opt,name=ipproto,proto3" json:"ipproto,omitempty"`
	// Port number
	Sport                int32        `protobuf:"varint,8,opt,name=sport,proto3" json:"sport,omitempty"`
	Dport                int32        `protobuf:"varint,9,opt,name=dport,proto3" json:"dport,omitempty"`
	DeviceSn             string       `protobuf:"bytes,10,opt,name=device_sn,json=deviceSn,proto3" json:"device_sn,omitempty"`
	Logmessage           string       `protobuf:"bytes,11,opt,name=logmessage,proto3" json:"logmessage,omitempty"`
	Note                 string       `protobuf:"bytes,12,opt,name=note,proto3" json:"note,omitempty"`
	Username             string       `protobuf:"bytes,13,opt,name=username,proto3" json:"username,omitempty"`
	Srciface             string       `protobuf:"bytes,14,opt,name=srciface,proto3" json:"srciface,omitempty"`
	Dstiface             string       `protobuf:"bytes,15,opt,name=dstiface,proto3" json:"dstiface,omitempty"`
	ProtoName            string       `protobuf:"bytes,16,opt,name=proto_name,json=protoName,proto3" json:"proto_name,omitempty"`
	Devmac               []byte       `protobuf:"bytes,17,opt,name=devmac,proto3" json:"devmac,omitempty"`
	Count                uint32       `protobuf:"varint,18,opt,name=count,proto3" json:"count,omitempty"`
	TrafficLog           *TrafficLog  `protobuf:"bytes,19,opt,name=traffic_log,json=trafficLog,proto3" json:"traffic_log,omitempty"`
	IdpLog               *IDPLog      `protobuf:"bytes,20,opt,name=idp_log,json=idpLog,proto3" json:"idp_log,omitempty"`
	FirewallLog          *FirewallLog `protobuf:"bytes,21,opt,name=firewall_log,json=firewallLog,proto3" json:"firewall_log,omitempty"`
	GeoSrc               *GEOIPLog    `protobuf:"bytes,22,opt,name=geo_src,json=geoSrc,proto3" json:"geo_src,omitempty"`
	GeoDst               *GEOIPLog    `protobuf:"bytes,23,opt,name=geo_dst,json=geoDst,proto3" json:"geo_dst,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *Devicelog) Reset()         { *m = Devicelog{} }
func (m *Devicelog) String() string { return proto.CompactTextString(m) }
func (*Devicelog) ProtoMessage()    {}
func (*Devicelog) Descriptor() ([]byte, []int) {
	return fileDescriptor_23da1a2e7ed79914, []int{6}
}

func (m *Devicelog) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Devicelog.Unmarshal(m, b)
}
func (m *Devicelog) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Devicelog.Marshal(b, m, deterministic)
}
func (m *Devicelog) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Devicelog.Merge(m, src)
}
func (m *Devicelog) XXX_Size() int {
	return xxx_messageInfo_Devicelog.Size(m)
}
func (m *Devicelog) XXX_DiscardUnknown() {
	xxx_messageInfo_Devicelog.DiscardUnknown(m)
}

var xxx_messageInfo_Devicelog proto.InternalMessageInfo

func (m *Devicelog) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *Devicelog) GetSeverity() int32 {
	if m != nil {
		return m.Severity
	}
	return 0
}

func (m *Devicelog) GetFacility() int32 {
	if m != nil {
		return m.Facility
	}
	return 0
}

func (m *Devicelog) GetCategory() string {
	if m != nil {
		return m.Category
	}
	return ""
}

func (m *Devicelog) GetSrcip() []byte {
	if m != nil {
		return m.Srcip
	}
	return nil
}

func (m *Devicelog) GetDstip() []byte {
	if m != nil {
		return m.Dstip
	}
	return nil
}

func (m *Devicelog) GetIpproto() int32 {
	if m != nil {
		return m.Ipproto
	}
	return 0
}

func (m *Devicelog) GetSport() int32 {
	if m != nil {
		return m.Sport
	}
	return 0
}

func (m *Devicelog) GetDport() int32 {
	if m != nil {
		return m.Dport
	}
	return 0
}

func (m *Devicelog) GetDeviceSn() string {
	if m != nil {
		return m.DeviceSn
	}
	return ""
}

func (m *Devicelog) GetLogmessage() string {
	if m != nil {
		return m.Logmessage
	}
	return ""
}

func (m *Devicelog) GetNote() string {
	if m != nil {
		return m.Note
	}
	return ""
}

func (m *Devicelog) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *Devicelog) GetSrciface() string {
	if m != nil {
		return m.Srciface
	}
	return ""
}

func (m *Devicelog) GetDstiface() string {
	if m != nil {
		return m.Dstiface
	}
	return ""
}

func (m *Devicelog) GetProtoName() string {
	if m != nil {
		return m.ProtoName
	}
	return ""
}

func (m *Devicelog) GetDevmac() []byte {
	if m != nil {
		return m.Devmac
	}
	return nil
}

func (m *Devicelog) GetCount() uint32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *Devicelog) GetTrafficLog() *TrafficLog {
	if m != nil {
		return m.TrafficLog
	}
	return nil
}

func (m *Devicelog) GetIdpLog() *IDPLog {
	if m != nil {
		return m.IdpLog
	}
	return nil
}

func (m *Devicelog) GetFirewallLog() *FirewallLog {
	if m != nil {
		return m.FirewallLog
	}
	return nil
}

func (m *Devicelog) GetGeoSrc() *GEOIPLog {
	if m != nil {
		return m.GeoSrc
	}
	return nil
}

func (m *Devicelog) GetGeoDst() *GEOIPLog {
	if m != nil {
		return m.GeoDst
	}
	return nil
}

func init() {
	proto.RegisterType((*EchoRequest)(nil), "monitorproxy.EchoRequest")
	proto.RegisterType((*EchoReply)(nil), "monitorproxy.EchoReply")
	proto.RegisterType((*TrafficLog)(nil), "monitorproxy.TrafficLog")
	proto.RegisterType((*IDPLog)(nil), "monitorproxy.IDPLog")
	proto.RegisterType((*FirewallLog)(nil), "monitorproxy.FirewallLog")
	proto.RegisterType((*GEOIPLog)(nil), "monitorproxy.GEOIPLog")
	proto.RegisterType((*Devicelog)(nil), "monitorproxy.Devicelog")
}

func init() {
	proto.RegisterFile("mpToNebula.proto", fileDescriptor_23da1a2e7ed79914)
}

var fileDescriptor_23da1a2e7ed79914 = []byte{
	// 699 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x54, 0xcb, 0x6e, 0x13, 0x3d,
	0x14, 0xfe, 0x93, 0xc9, 0x6d, 0x4e, 0xd2, 0xfe, 0xc1, 0xf4, 0x62, 0xca, 0x45, 0x25, 0x1b, 0xba,
	0xa1, 0x48, 0x65, 0x85, 0xd4, 0x0d, 0xa2, 0x05, 0x15, 0x41, 0x41, 0x6e, 0xf7, 0x91, 0xe3, 0x71,
	0x06, 0x4b, 0x33, 0xe3, 0xc1, 0x76, 0x42, 0xf3, 0x0a, 0x48, 0x3c, 0x03, 0x0f, 0xc8, 0x4b, 0x20,
	0x1f, 0xcf, 0xe4, 0x52, 0x15, 0xb1, 0x61, 0x77, 0xbe, 0xef, 0xf8, 0x3b, 0xfe, 0x7c, 0xec, 0x63,
	0x18, 0xe6, 0xe5, 0xb5, 0xbe, 0x94, 0x93, 0x59, 0xc6, 0x8f, 0x4b, 0xa3, 0x9d, 0x26, 0x83, 0x5c,
	0x17, 0xca, 0x69, 0x53, 0x1a, 0x7d, 0xb3, 0x18, 0x3d, 0x83, 0xfe, 0xb9, 0xf8, 0xa2, 0x99, 0xfc,
	0x3a, 0x93, 0xd6, 0x11, 0x0a, 0xdd, 0x5c, 0x5a, 0xcb, 0x53, 0x49, 0x1b, 0x87, 0x8d, 0xa3, 0x98,
	0xd5, 0x70, 0xf4, 0x1a, 0xe2, 0xb0, 0xb0, 0xcc, 0x16, 0x7f, 0x5e, 0x46, 0x0e, 0xa0, 0x37, 0x2b,
	0xd4, 0x8d, 0x53, 0xb9, 0xa4, 0xcd, 0xc3, 0xc6, 0x51, 0xc4, 0x96, 0x78, 0xf4, 0xb3, 0x01, 0x70,
	0x6d, 0xf8, 0x74, 0xaa, 0xc4, 0x07, 0x9d, 0xfa, 0xa5, 0xc9, 0xcc, 0x70, 0xa7, 0x74, 0x81, 0x55,
	0xb6, 0xd8, 0x12, 0x13, 0x02, 0x2d, 0x2b, 0x0b, 0x87, 0x25, 0x5a, 0x0c, 0x63, 0xbf, 0xde, 0x48,
	0x21, 0xd5, 0x5c, 0x26, 0x34, 0x42, 0x7e, 0x89, 0xc9, 0x10, 0xa2, 0x44, 0x19, 0xda, 0x42, 0x33,
	0x3e, 0x24, 0x3b, 0xd0, 0xc6, 0xf3, 0xd2, 0x36, 0x96, 0x0e, 0x80, 0x3c, 0x06, 0xc0, 0x60, 0x5c,
	0xf0, 0x5c, 0xd2, 0x0e, 0x2e, 0x8f, 0x91, 0xb9, 0xe4, 0xb9, 0x1c, 0x49, 0xe8, 0x5c, 0x9c, 0x7d,
	0xf6, 0xe6, 0x86, 0x10, 0x89, 0xcc, 0x56, 0xa7, 0xf3, 0xa1, 0x67, 0xb8, 0x08, 0x8e, 0x62, 0xe6,
	0x43, 0xcf, 0x58, 0x15, 0xbc, 0x6c, 0x31, 0x1f, 0x92, 0x6d, 0x68, 0xea, 0x49, 0xe5, 0xa2, 0xa9,
	0x27, 0x64, 0x17, 0x3a, 0x7a, 0x32, 0xce, 0xb9, 0x40, 0x17, 0x03, 0xd6, 0xd6, 0x93, 0x8f, 0x5c,
	0x8c, 0x7e, 0x34, 0xa0, 0xff, 0x56, 0x19, 0xf9, 0x8d, 0x67, 0xd9, 0xdd, 0x9b, 0x85, 0x42, 0xcd,
	0x3b, 0x0a, 0x45, 0x6b, 0x85, 0xfe, 0xd5, 0xb1, 0xbf, 0x37, 0xa0, 0xf7, 0xee, 0xfc, 0xd3, 0x05,
	0x9e, 0xfc, 0x29, 0x0c, 0x84, 0x9e, 0x15, 0xce, 0x2c, 0xc6, 0x42, 0x27, 0xf5, 0x05, 0xf7, 0x2b,
	0xee, 0x8d, 0x4e, 0x24, 0x79, 0x08, 0xb1, 0x50, 0xae, 0xca, 0x07, 0x93, 0x3d, 0x4f, 0x60, 0x72,
	0x4d, 0x8f, 0xbb, 0x45, 0x1b, 0x7a, 0xbf, 0xdf, 0x52, 0x8f, 0xf9, 0xd6, 0x4a, 0x8f, 0x66, 0x7e,
	0xb5, 0x21, 0x3e, 0x93, 0x73, 0x25, 0x64, 0xa6, 0x53, 0xf2, 0x08, 0x62, 0xff, 0x76, 0xac, 0xe3,
	0x79, 0x89, 0x56, 0x22, 0xb6, 0x22, 0xfc, 0x93, 0xb0, 0x72, 0x2e, 0x8d, 0x72, 0x0b, 0xf4, 0xd1,
	0x66, 0x4b, 0xec, 0x73, 0x53, 0x2e, 0x54, 0xe6, 0x73, 0x51, 0xc8, 0xd5, 0xd8, 0xe7, 0x04, 0x77,
	0x32, 0xd5, 0x66, 0xb1, 0xdc, 0xbf, 0xc2, 0xbe, 0x83, 0xd6, 0x08, 0x55, 0xd6, 0x57, 0x86, 0xc0,
	0xb3, 0x89, 0x75, 0xaa, 0xc4, 0xe6, 0x0d, 0x58, 0x00, 0x7e, 0x0e, 0x54, 0x19, 0xfa, 0xdd, 0xc5,
	0x2d, 0x6a, 0x88, 0x55, 0x4a, 0x6d, 0x1c, 0xed, 0x21, 0x1f, 0x00, 0x56, 0x41, 0x36, 0x0e, 0x2c,
	0x02, 0xdf, 0x8e, 0x04, 0x0f, 0x3c, 0xb6, 0x05, 0x85, 0x60, 0x27, 0x10, 0x57, 0x05, 0x79, 0x02,
	0x90, 0xe9, 0xb4, 0x9e, 0xb6, 0x3e, 0x66, 0xd7, 0x18, 0x3f, 0x29, 0x85, 0x76, 0x92, 0x0e, 0x30,
	0x83, 0x31, 0x0e, 0xa1, 0x95, 0x06, 0xdb, 0xbb, 0x15, 0xea, 0xd5, 0x18, 0x5b, 0x66, 0x84, 0x9a,
	0x72, 0x21, 0xe9, 0x76, 0xc8, 0xd5, 0x18, 0x27, 0xd2, 0xba, 0x90, 0xfb, 0xbf, 0xf2, 0x51, 0xe1,
	0x5b, 0x4f, 0x68, 0x78, 0xeb, 0x09, 0x91, 0x3d, 0xe8, 0x24, 0x72, 0xee, 0x1f, 0xe8, 0x3d, 0x6c,
	0x50, 0x85, 0xfc, 0x89, 0xf1, 0xe6, 0x29, 0x09, 0xef, 0x11, 0x01, 0x79, 0x05, 0x7d, 0x17, 0x3e,
	0x82, 0x71, 0xa6, 0x53, 0x7a, 0xff, 0xb0, 0x71, 0xd4, 0x3f, 0xa1, 0xc7, 0xeb, 0x3f, 0xd3, 0xf1,
	0xea, 0xa7, 0x60, 0xe0, 0x56, 0xbf, 0xc6, 0x73, 0xe8, 0xaa, 0xa4, 0x44, 0xd9, 0x0e, 0xca, 0x76,
	0x36, 0x65, 0x61, 0x7e, 0x59, 0x47, 0x25, 0xa5, 0x5f, 0x7e, 0x0a, 0x83, 0x69, 0x35, 0x69, 0xa8,
	0xd9, 0x45, 0xcd, 0x83, 0x4d, 0xcd, 0xda, 0x2c, 0xb2, 0xfe, 0x74, 0x6d, 0x30, 0x5f, 0x40, 0x37,
	0x95, 0x7a, 0x6c, 0x8d, 0xa0, 0x7b, 0x28, 0xdc, 0xdb, 0x14, 0xd6, 0x43, 0xc3, 0x3a, 0xa9, 0xd4,
	0x57, 0x46, 0xd4, 0x82, 0xc4, 0x3a, 0xba, 0xff, 0x57, 0xc1, 0x99, 0x75, 0x27, 0xef, 0x01, 0xfc,
	0xb7, 0x7a, 0x25, 0xcd, 0x5c, 0x1a, 0x72, 0x0a, 0x2d, 0x8f, 0xc8, 0x2d, 0x7f, 0x6b, 0x3f, 0xf4,
	0xc1, 0xfe, 0x5d, 0xa9, 0x32, 0x5b, 0x8c, 0xfe, 0x9b, 0x74, 0xf0, 0x3a, 0x5e, 0xfe, 0x0e, 0x00,
	0x00, 0xff, 0xff, 0x28, 0xb4, 0x02, 0xfb, 0xf4, 0x05, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// EchoServerClient is the client API for EchoServer service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type EchoServerClient interface {
	Echo(ctx context.Context, in *EchoRequest, opts ...grpc.CallOption) (*EchoReply, error)
}

type echoServerClient struct {
	cc grpc.ClientConnInterface
}

func NewEchoServerClient(cc grpc.ClientConnInterface) EchoServerClient {
	return &echoServerClient{cc}
}

func (c *echoServerClient) Echo(ctx context.Context, in *EchoRequest, opts ...grpc.CallOption) (*EchoReply, error) {
	out := new(EchoReply)
	err := c.cc.Invoke(ctx, "/monitorproxy.EchoServer/Echo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EchoServerServer is the server API for EchoServer service.
type EchoServerServer interface {
	Echo(context.Context, *EchoRequest) (*EchoReply, error)
}

// UnimplementedEchoServerServer can be embedded to have forward compatible implementations.
type UnimplementedEchoServerServer struct {
}

func (*UnimplementedEchoServerServer) Echo(ctx context.Context, req *EchoRequest) (*EchoReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Echo not implemented")
}

func RegisterEchoServerServer(s *grpc.Server, srv EchoServerServer) {
	s.RegisterService(&_EchoServer_serviceDesc, srv)
}

func _EchoServer_Echo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EchoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EchoServerServer).Echo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/monitorproxy.EchoServer/Echo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EchoServerServer).Echo(ctx, req.(*EchoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _EchoServer_serviceDesc = grpc.ServiceDesc{
	ServiceName: "monitorproxy.EchoServer",
	HandlerType: (*EchoServerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Echo",
			Handler:    _EchoServer_Echo_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "mpToNebula.proto",
}
